Bool {
    Program = Block

    // single line comments must exist on their own lines for now
    // multi line comments must either exist on their own or at the terminus
    // of a line
    Block
        = (FullStmt | singlecomment)*
    FullStmt = Stmt? newline
    Stmt
      = ClassDecl
      | FunDecl
      | ObjDecl
      | VarDecl     -- vardecl
      | OpAssign
      | VarAssignment
      | Conditional
      | Loop        -- loop
      | Exp         -- exp
      | Return      -- ret

    ClassDecl
        = "class" id ("isa" id)? ":" ClassSuite

    ClassSuite
        = newline indent ClassBody dedent

    ClassBody
        = (fielddecl newline)* ConstructorDecl MethodDecl+

    fielddecl
      = "_" id

    ConstructorDecl
      = "build" Params ":" Suite

    MethodDecl
        = id methodparams ":" Suite
    methodparams
        = "(" ((id | fielddecl) (" " (id | fielddecl))*)? ")"

    // need to make this work where second newline not necessary before closing dedent
    ObjDecl
        = id ":=" newline indent (PropertyDecl newline)* dedent

    // may need to expand this
    PropertyDecl
      = VarExp ":" Exp

    FunDecl
      = "fun" id Type? Params ":" Suite

    VarDecl
      = "let" VarExp (Type)? ("=" Exp)?

    OpAssign
      = id (assignop) Exp

    assignop
      = "+=" | "*=" | "/=" | "%="

    VarAssignment
      = VarExp "=" Exp

    Return = "ret" Exp

    Funcall
      = id Funparams+

    Funparams
      = "(" SimpleLit* ")"

    Params
      = "(" ParamDecl* ")"

    ParamDecl
      = id Type?

    Conditional
      = "if" Case ("elif" Case)* ("el" ":" Suite)?

    Case
      = Exp ":" Suite

    Suite
      = newline indent (Stmt newline)+ dedent

    SimpleSuite
      = (newline indent)? Exp newline dedent

    Loop
        = "for" id "in" (Range | id | Listlit ) ":" Suite     --forIn
        | "while" Exp ":" Suite                               --while
        | "do" ":" Suite "until" Exp                          --doUntil
        | "do" ":" Suite "while" Exp                          --doWhile

    Exp
      = Exp1 "or" Exp1      --binexp
      | Exp1
    Exp1
      = Exp2 "and" Exp2     --binexp
      | Exp2
    Exp2
      = Exp3 relop Exp3     --binexp
      | Exp3
    Exp3
      = Exp4 addop Exp4     --binexp
      | Exp4
    Exp4
      = Exp5 mulop Exp5     --binexp
      | Exp5
    Exp5
      = Exp6 expop Exp6     --expExp
      | Exp6
    Exp6
      = prefixop Exp7       --prefixOp
      | Exp7
    // may need to make this lexical
    Exp7
      = Exp8 "." Exp8       --access
      | Exp8 "[" Exp8 "]"   --listAccess
      | Exp8
    Exp8
      =
      | "(" Exp ")"   --parens
      | SimpleLit
      | Funlit
      | Objlit
      | Listlit
      | fielddecl
      | ClassInst

    // need to add support for single line objects
    // May also want support for lists
    SimpleLit
      = boollit
      | floatlit
      | intlit
      | Funcall
      | VarExp
      | stringlit

    VarExp = id
    addop = "+" | "-"
    mulop = "*" | "/" | "%"
    prefixop = "!" | "-"
    expop = "**" | "//"
    relop =  ">=" | "<=" | ">" | "<" | "!==" | "===" | "==" | "!="
    Explist = Exp8 ("," Exp8)*
    ListExp = Exp "for" id "in" (id | Listlit) SimpleIf?
    SimpleIf = "if" Exp
    Listlit = "[" (ListExp | Explist)? "]"
    Range = "range(" RangeExp ")"
    RangeExp = intlit ("," intlit("," "-"? intlit)?)?
    boollit = "tru" | "fal"
    intlit = ~(digit* ".") digit+
    floatlit = digit+ "." (digit+)? | (digit+)? "." digit+
    stringlit = "\"" char* "\"" | "\'" char* "\'"
    ClassInst = "new" id Funparams

    Objlit
      = "{" PropertyDecl? "}" --singleprop
      | "{" newline indent (PropertyDecl newline)* dedent "}" --multiprop

    // should also allow for one line statement here
    Funlit = Params ":" Suite

    reserved
      = "tru" | "fal" | "fun" | "if" | "elif" | "el" | "for" | "do"
      | "while" | "until" | "build" | "class" | "isa" | "in" | "new" | "#" | "ret"
      | "indent" | "dedent" | "[" | "]" | "let" | "string" | "float" | "int"
      | "bool" | "obj" | addop | mulop | expop
      | relop
    Type
      = ":" ("string" | "float" | "int" | "bool" | "obj" | id) --single
      | ":" "[" ("string" | "float" | "int" | "bool" | "obj" | id) "]" --list
    char
         = alnum | punctuation | escape | stringSpace

    stringSpace
         = " " | "\t" | "\n"

    punctuation
         = "." | "," | "/" | "<" | ">" | "?" | ":" | ";" | "{" | "}" | "["
         | "]" | "|" | "+" | "=" | "-" | "_" | "(" | ")" | "!" | "@" | "#"
         | "$" | "%" | "^" | "&" | "*"

    escape = "\\" // still need to fully define these
    comment
      = multicomment
      | singlecomment
    singlecomment =  "#" ~"#" (~"\n" any)* "\n"
    multicomment = "##" (~"##" any)* "##"
    indent = "indent" // placeholder
    dedent = "dedent" // placeholder
    id = ~("_"? reserved ~(idChar+)) idName
    idName = idStart (idChar)*
    idStart = letter | "$"
    idChar = alnum | "-" | "_"
    newline = "\n" | "\r" | "\u2028" | "\u2029"
    // may need to amend this rule
    space := " " | "\t" | multicomment
}
